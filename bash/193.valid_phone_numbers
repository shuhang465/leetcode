# 给定一个包含电话号码列表（一行一个电话号码）的文本文件 file.txt，写一个单行 bash 脚本输出所有有效的电话号码。

# 你可以假设一个有效的电话号码必须满足以下两种格式： (xxx) xxx-xxxx 或 xxx-xxx-xxxx。（x 表示一个数字）

# 你也可以假设每行前后没有多余的空格字符。



# 这道题目主要考察正则表达式和行匹配工具。关于正则表达式的文章可以参看：SHELL编程正则表达式，这一篇就够了，grep 行匹配命令可以参看：Shell编程之文本处理工具与bash的特性。



# 解决此问题，只要写出两种电话号码格式 (xxx) xxx-xxxx 或 xxx-xxx-xxxx 所对应的正则表达式即可：



# (xxx) xxx-xxxx 所对应的正则表达式最笨的写法：

# '\([0-9][0-9][0-9]\) [0-9][0-9][0-9]-[0-9][0-9][0-9][0-9]'
# '[(][0-9][0-9][0-9][)] [0-9][0-9][0-9]-[0-9][0-9][0-9][0-9]'
# 也就是把每一个x换成数字[0-9]，再将给小括号加上反斜杠进行转义或者放进一对中括号内即可。

# xxx-xxx-xxxx 则可以表示为：

# '[0-9][0-9][0-9]-[0-9][0-9][0-9]-[0-9][0-9][0-9][0-9]'


# 对上面两种正则表达式做进一步的简化：

# '\([0-9]{3}\) [0-9]{3}-[0-9]{4}'
# '[(][0-9]{3}[)] [0-9]{3}-[0-9]{4}'
# '[0-9]{3}-[0-9]{3}-[0-9]{4}'


# 此处再给出另外一种电话号码的正则表达式表示方式：

# #\d 是基于 Perl 的正则表达式
# #(xxx) xxx-xxxx
# '[(]\d{3}[)] \d{3}-\d{4}'
# '\(\d{3}\) \d{3}-\d{4}'
# #xxx-xxx-xxxx
# '\d{3}-\d{3}-\d{4}'


# 有了上面我们总结出来的正则表达式，进行行匹配就简单多了，只需要一个或|就可以将两个正则表达式连在一起：

# '\(\d{3}\) \d{3}-\d{4}|\d{3}-\d{3}-\d{4}'
# '[(]\d{3}[)] \d{3}-\d{4}|\d{3}-\d{3}-\d{4}'
# '\([0-9]{3}\) [0-9]{3}-[0-9]{4}|[0-9]{3}-[0-9]{3}-[0-9]{4}'


# 使用或运算连接在一起，你如果觉得还不够简化可以再提取出两个正则中相同的部分，则表示为：

# '(\(\d{3}\) |\d{3}-)\d{3}-\d{4}'
# '([(]\d{3}[)] |\d{3}-)\d{3}-\d{4}'
# '(\([0-9]{3}\) |[0-9]{3}-)[0-9]{3}-[0-9]{4}'


# 最后匹配出电话号码格式正确的就轻而易举：

grep -P '(\(\d{3}\) |\d{3}-)\d{3}-\d{4}' file.txt
grep -P '([(]\d{3}[)] |\d{3}-)\d{3}-\d{4}' file.txt
grep -E '(\([0-9]{3}\) |[0-9]{3}-)[0-9]{3}-[0-9]{4}' file.txt
